# <center> 图为C/C++编程规范</center>



# 0 前言

## 0.1 规范制定说明

编程规范是对软件开发人员编写代码提出一些要求，以约束代码的使用和编写风格。希望通过规范来帮助或指导软件开发人员写出易读、可维护、可靠、可测试、高效、可移植的代码。

编程规范中的各种条目并不是毫无理由的提出，编程规范修订组分析总结了各种典型的编码问题，并参考业界编程规范，制定本规范。

## 0.2 代码总体原则

**“程序必须为阅读它的人而编写，只是顺便用于机器执行。”**

​                                                                                                    ——Harold Abelson 和 Gerald Jay Sussman

**“编写程序应该以人为本，计算机第二。”**

​                                                                                                     ——Steve McConnell

软件开发人员工作中有相当多的时间不是写新的代码，而是维护修改现有的代码，看代码的过程常常很痛苦，想一遍遍的问编写者的具体意图，希望别人写的代码逻辑清晰，注释意义明确。逻辑清晰的代码，意义明确的注释，这就是高质量代码的第一要求。
代码第一原则：易读。

## 0.3 术语定义

原则：编程时必须坚持的指导思想。

规则：编程时强制必须遵守的约定。

建议：编程时必须加以考虑的约定。

说明：对此原则/规则/建议进行必要的解释。

# 1 排版
好的排版不会直接带来新的功能或者性能的提高，但是好的排版却能提高阅读代码的效率，反之，排版差的代码会降低阅读理解的效率，例如，在复杂逻辑多层嵌套出现时，括号没有对齐可能导致阅读者理解错逻辑关系，又例如，有多层括号的表达式，操作符和操作数密密麻麻挤在一起，任谁也难以轻易看出括号的匹配关系。

## 1.1 通用规则

**【建议】  在代码编辑器中，将字体设置为等宽字体。**  

在代码编辑器中，建议设置为等宽字体，例如Consolas、Courier New等，便于代码对齐。  

**【规则】代码行每次缩进4个空格，并且不使用tab** 。

在不同的编辑器中，一个tab的宽度是不同的，如果tab和空格混用，会导致在一个编辑器中排版好的代码在另一个编辑器中打开时对不齐。  

例如，下图为在VS中编写好的代码  

![VS代码的对齐](.\picture\Snipaste_2019-01-11_16-32-58.png)  

在记事本中打开，代码就乱了 ![notepad代码的对齐](.\picture\Snipaste_2019-01-11_16-37-48.png)  查看VS中代码，显示空格和tab后
![VS代码的对齐](.\picture\Snipaste_2019-01-11_16-40-48.png)  可以看出在编写代码时tab和空格混用，在VS中一个tab宽度为4个空格，而在记事本中一个tab宽度为8个空格，所以导致记事本中显示的代码格式混乱。

**【规则】程序的分界符`{`和`}`应独占一行并且位于同一列，同时与引用它们的语句左对齐。**

对于空函数体，可以将大括号放在同一行。

```C++
void DoNothing(void)
{
    {
        {
            ;
            ;
        }
    }
    
    ;
    ;
    {
        ;
    }
}

if (...)
{
    ;
}
else
{}
```

**【规则】同一缩进层次的代码必须左对齐。**

**【建议】一行代码只做一件事，即只声明一个变量或者只写一条语句。**

```C++
// 推荐
int minValue;
int maxValue;

if (value > maxValue)
{
    maxValue = value;
}

// 不推荐
int minValue, maxValue;

if (value > maxValue) maxValue = value;
```

**【建议】代码行不宜过长（不要超过120个字符），可在低优先级操作符处拆分为多行，低优先级操作符放在新行行首，并且适当缩进。**

```C++
    vdcBusFlt = 0.99373651262477824541718973705429f * vdcBusFlt
              + 0.0062634873752217745321302366789951f * vdcBusBak;

    if((rectifier.state.runState == REC_NORMALRUN)
    && (charger.state.selfTestFinish == 0))
    {
        ；
    }
```

例外：

- 如果一行注释包含了超过120 个字符的命令或URL，则可以保持一行，以方便复制、粘贴和通过grep查找；
- 包含长路径的 #include 语句可以超出120 个字符，但是也需要尽量避免；
- 编译预处理中的error信息可以超出一行。 预处理的 error 信息在一行便于阅读和理解，即使超过 120 个字符。

## 1.2 文件

**【规则】头文件排版内容依次为包含的头文件、宏定义、类型定义、声明变量、声明函数。各个种类的内容间空一行。**

头文件是模块对外的公用接口，在头文件中定义的宏，可以被其他模块引用。项目中不建议使用全局变量，若使用则需在头文件里对外声明。模块对外的函数接口在模块头文件里声明。

## 1.3 预处理

**【规则】编译预处理的"#"统一放在行首，嵌套编译预处理语句时，"#"不缩进。**

编译预处理的"#"统一放在行首，即使编译预处理的代码是嵌入在函数体中的，"#"也应该放在行首。

```C++
#if defined(__x86_64__) && defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_16) // Good
#define ATOMIC_X86_HAS_CMPXCHG16B 1  // Good："#"放在行首
#else
#define ATOMIC_X86_HAS_CMPXCHG16B 0
#endif 

int FunctionName()
{
    if (someThingError)
    {
        ...
#ifdef HAS_SYSLOG  // Good：即便在函数内部，"#"也放在行首
        WriteToSysLog();
#else
        WriteToFileLog();
#endif
    }
}
```



## 1.4 空格和空行

恰当的空行和空格可以使程序结构清晰，段落感强，有助于提高代码的阅读效率，反之，如果没有空行，程序密密麻麻，不容易理解程序功能，也使人眼花，过多的空行，来回翻页也累人。

**【规则】水平空格应该突出关键字和重要信息，避免不必要的留白。**

水平空格应该突出关键字和重要信息，每行代码尾部不要加空格。总体规则如下：

- if，switch，case，do，while，for，const，virtual，inline，case等关键字之后加空格；
- 小括号内部的两侧，不要加空格；
- 大括号内部两侧有无空格，左右必须保持一致；
- 一元操作符（& * + ‐ ~ !）之后不要加空格；
- 二元操作符（= + ‐ < > * / % | & ^ <= >= == != ）左右两侧加空格
- 三目运算符（? :）符号两侧均需要空格
- 前置和后置的自增、自减（++ --）和变量之间不加空格
- 结构体成员操作符（. ->）前后不加空格
- 逗号(,)前面不加空格，后面增加空格
- 对于模板和类型转换(<>)和类型之间不要添加空格
- 域操作符(::)前后不要添加空格
- 冒号(:)前后根据情况来判断是否要添加空格

常规情况

```C++
int i = 0;  // Good：变量初始化时，=前后应该有空格，分号前面不要留空格
int buf[kBufSize] = {0};    // Good：大括号内两侧都无空格
```

函数定义和函数调用

```C++
int result = Foo(arg1,arg2);  // Bad: 逗号后面需要增加空格
int result = Foo( arg1, arg2 ); // Bad: 函数参数列表左括号后不应有空格，右括号前不应有空格
```

指针和取地址

```C++
x = *p;     // Good：*操作符和指针p之间不加空格
p = &x;     // Good：&操作符和变量x之间不加空格
x = r.y;    // Good：通过.访问成员变量时不加空格
x = r->y;   // Good：通过->访问成员变量时不加空格
```

操作符

```C++
x = 0；   // Good：赋值操作的=前后都要加空格
x = -5；  // Good：负数的符号和数值之前不要加空格
++x；     // Good：前置和后置的++/--和变量之间不要加空格
x--；

if (x && !y)  // Good：布尔操作符前后要加上空格，！操作和变量之间不要空格
v = w * x + y / z;  // Good：二元操作符前后要加空格
v = w * (x + z);    // Good：括号内的表达式前后不需要加空格

int a = (x < y) ? x : y;  // Good: 三目运算符， ？和：前后需要添加空格
```

循环和条件语句

```C++
if (condition)  // Good：if关键字和括号之间加空格，括号内条件语句前后不加空格
{  
    ...
} 
else  // Good：else独占一行
{           
    ...
}

while (condition)  // Good：while关键字和括号之间加空格，括号内条件语句前后不加空格
{}   

for (int i = 0; i < someRange; ++i)  // Good：for关键字和括号之间加空格，分号之后加空格
{  
    ...
}

switch (condition)  // Good: switch 关键字后面有1空格
{  
    case 0:  // Good：case语句条件和冒号之间不加空格
        ...
        break;
        ...
    default:
        ...
        break;
}
```

模板和转换

```C++
// 尖括号(< and >) 不与空格紧邻, < 前没有空格, > 和 ( 之间也没有.
vector<string> x;
y = static_cast<char*>(x);

// 在类型与指针操作符之间留空格也可以, 但要保持一致.
vector<char *> x;
```

域操作符

```C++
std::cout;    // Good: 命名空间访问，不要留空格

int MyClass::GetValue() const {}  // Good: 对于成员函数定义，不要留空格
```

冒号

```C++
// 添加空格的场景

// Good: 类的派生需要留有空格
class Sub : public Base
{

};

// 构造函数初始化列表需要留有空格
MyClass::MyClass(int var) : someVar(var)
{
    DoSomething();
}

// 位域表示也留有空格
struct XX
{
    char a : 4;     
    char b : 5;     
    char c : 4;
};
```

```C++
// 不添加空格的场景

// Good: 对于public:, private:这种类访问权限的冒号不用添加空格
class MyClass
{
 public:
    MyClass(int var);
 private:
    int someVar;
};

// 对于switch-case的case和default后面的冒号不用添加空格
switch (value)
{
    case 1:
        DoSomething();
        break;
    default:
        break;
}
```

**【原则】合理安排空行，保持代码紧凑。**

减少不必要的空行，可以显示更多的代码，方便代码阅读。下面有一些建议遵守的规则：

- 根据上下内容的相关程度，合理安排空行；
- 函数内部、类型定义内部、宏内部、初始化表达式内部，不使用连续空行
- 不使用连续 **3** 个空行，或更多
- 大括号内的代码块行首之前和行尾之后不要加空行。

**【规则】函数定义、数据类型、类等声明结束后应有一行空行。 **

普通函数

```c++
float CalcRectangleArea(float length, float width)
{
    float area;
    
    area = length * width;
    return area;
}

```

类成员函数/类方法

```C++
float Box::CalcRectangleArea(void)
{
    return length * width;
}

```

类声明

```C++
class Box
{
 public:
    float GetLength(void);
    void  SetLength(float length);
    float GetWidth(void);
    void  SetWidth(float width);
    float GetHeight(void);
    void  SetHeight(float height);
    
 private:
    float m_length;
    float m_width;
    float m_height;
};

```

**【规则】不同的程序功能块，或者不同的逻辑段落之间必须有一行空行。**

**【规则】大括号内的代码块行首之前和行尾之后不要加空行。**

```C++
if (...)
{
        // Bad：大括号内的代码块行首不要加入空行
    ...
        // Bad：大括号内的代码块行尾不要加入空行
}

int Foo(...)
{
        // Bad：函数体内行首不要加空行
    ...
}
```

**【建议】空行不宜过多，需要空行的地方空一行就可以。**



## 1.5 表达式

**【规则】一元运算符和操作数之间不加空格。**

作用于一个运算对象的运算符是一元运算符，如取地址符&和解引用符*。一元运算符如下

| 运算符 | 名称         |
| ------ | ------------ |
| **!**  | 逻辑“非”     |
| **&**  | 取地址       |
| ~      | 按位取反     |
| **\*** | 指针取消引用 |
| **+**  | 正           |
| ++     | 递增         |
| **–**  | 负           |
| **––** | 递减         |

代码示例

```C++
    i++;
    pBox = &box;  // pBox是指向box的指针
```

**【规则】成员运算符`.`和` ->`前后不加空格。**

```c++
    box.length = 1.23;
    pBox = &box;  // pBox是指向box的指针
    pBox->width = 4.56;
```

**【建议】二元运算符和操作数之间加一个空格。**

作用于两个运算对象的运算符是二元运算符，如相等运算符==和乘法运算符*。

```C++
    rectangleArea = length * width;
```

**【规则】左括号`(`和右括号`)`与操作数之间不加空格。**

```c++
    average = (a + b + c) / 3;
```

**【规则】`[`之后和`]`之前不加空格。**

**【规则】`,`和`;`前面不加空格。**

**【建议】对于较长的表达式或语句，为了紧凑起见可以适当地去掉一些空格。**

```C++
    for (i=0; i<10; i++)
    {
        ;
    }

    if ((volt>LOW_VOLT) && (volt<HIGH_VOLT))
    {
        ;
    }

    root = (-b + sqrt(b*b-4*a*c)) / (2*a)；
```

## 1.6 结构体和类

**【规则】类访问控制块的声明依次序是 public:, protected:, private:，每个都缩进 1 个空格。**

对外使用的接口或变量放前面，只在类内部使用的成员变量或成员函数放后面。

```C++
class Box
{
 public:
    float length;
    float width;
    float height;

 private:
    float xx;

 public:
    float CalcVolume(void);

 private:
    float DoNothing(void);
};
```

在各个部分中，建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它成员函数, 数据成员。

**【规则】 构造函数初始化列表放在同一行或按四格缩进并排多行。**

```C++
// 如果所有变量能放在同一行:
MyClass::MyClass(int var) : someVar(var)
{
    DoSomething();
}

// 如果不能放在同一行,
// 必须置于冒号后, 并缩进4个空格
MyClass::MyClass(int var)
    : someVar(var), someOtherVar(var + 1)  // Good: 逗号后面留有空格
{ 
    DoSomething();
}

// 如果初始化列表需要置于多行, 需要逐行对齐
MyClass::MyClass(int var)
    : someVar(var),  // 缩进4个空格           
      someOtherVar(var + 1)
{  
    DoSomething();
}
```

**【建议】结构体声明与类声明类似。**

```C++
struct Box
{
    float length;
    float width;
    float height;
};
```

## 1.7 变量

**【建议】每一行只声明/定义一个变量。**

一行声明多个变量不但不方便注释每一个变量的含义，而且可能混淆变量的类型。

比如同一行包含指针和非指针的声明，易导致代码阅读者理解错误或代码犯错。

```C++
int * counter, quantity; // quantity是int类型指针吗？
```

**【规则】数据类型和变量之间加一个空格，也可根据实际代码对齐的需求增加空格数量，但是不要太多。**

```C++
// 根据实际情况对齐代码
int    value1;
float  value2;
int    value3;
double value4;
char   value5;
```

```C++
// 如果对齐需要添加的空格太多，所以此处不强制对齐
int value1;
struct Rectifier value2;
```

**【规则】初始化换行时要有缩进，并进行合理对齐。**

结构体或数组初始化时，如果换行应保持4空格缩进。 从可读性角度出发，选择换行点和对齐位置。

```C++
const int rank[] = 
{
    16, 16, 16, 16, 32, 32, 32, 32,
    64, 64, 64, 64, 32, 32, 32, 32
};
```

 **【规则】声明指针变量时，*靠近变量名。**

```C++
int *pCounter = NULL;
```

例外：当变量被 const 修饰时，"`*`" 无法跟随变量，此时也不要跟随类型。

```C++
char * const VERSION = "V100";
```

**【规则】引用类型"`&`"跟随变量名。**

```C++
int i = 8;
int &p = i;     // Good
```



## 1.8 语句

### if

**【规则】*if*和*else*独占一行。**

**【规则】*if*和*else*后面的语句，无论有多少行，必须放在{}中。**

理由：

- 代码逻辑直观，易读；
- 在已有条件语句代码上增加新代码时不容易出错；
- 对于在if语句中使用函数式宏时，有大括号保护不易出错（如果宏定义时遗漏了大括号）。

代码示例如下

```C++
    if (volt > 264.0f)
    {
        highVolt = 1;    
    }
    else if (volt < 186.0f)
    {
        lowVolt = 1;
    }
    else
    {
        highVolt = 0; 
        lowVolt  = 0;
    }
```



### switch

**【建议】*switch*必须有*default*分支。**

```C++
    switch(ch)
    {
        case 'A':
            ;
            ;
            break;
        case 'B':
            ;
            ;
            break
        default:
            ;
            break;
    }
```

### 循环语句

循环语句包括for、while和do-while。

**【规则】*for*，*while*，*do*语句独占一行。**

**【规则】*for*，*while*，*do*后面的语句，无论有多少行，必须放在{}中。**

如果循环体是空的，应该使用空的大括号，而不是使用单个分号。 单个分号容易被遗漏，也容易被误认为是循环语句中的一部分。

好的代码示例如下：

```C++
    for (int i=0; i<MAX_CNT; i++)
    {
        ;
        ;
    }
```

```C++
    while (i < MAX_CNT)
    {}
```

```C++
    do
    {
        ;
    } while(i < MAX_CNT)
```

不好的例子：

```C++
for (int i = 0; i < someRange; i++) ;  // Bad：for循环体是空，也不要只使用分号，要使用大括号

while (someCondition) ; // Bad：使用分号容易让人误解是while语句中的一部分
```



## 1.9 函数

**【规则】函数声明和定义的返回类型和函数名在同一行，函数参数列表超出行宽时要换行并合理对齐。**

在声明和定义函数的时候，函数的返回值类型应该和函数名在同一行；如果行宽度允许，函数参数也应该放在一行；否则，函数参数应该换行，并进行合理对齐。 参数列表的左圆括号总是和函数名在同一行，不要单独一行；右圆括号总是跟随最后一个参数。

```C++
// Good：全在同一行
ReturnType FunctionName(ArgType paramName1, ArgType paramName2)
{  
  ...
}

// 行宽不满足所有参数，进行换行
ReturnType VeryVeryVeryLongFunctionName(ArgType paramName1,     
                                        ArgType paramName2, // Good：和上一行参数对齐
                                        ArgType paramName3)
{
  ...
}

// 行宽限制，进行换行
ReturnType LongFunctionName(ArgType paramName1, ArgType paramName2, 
    ArgType paramName3, ArgType paramName4, ArgType paramName5) // Good:换行后4空格缩进
{     
  ...
}

// 行宽不满足第1个参数，直接换行
ReturnType ReallyReallyReallyReallyLongFunctionName(            
    ArgType paramName1, ArgType paramName2, ArgType paramName3) // Good:换行后4空格缩进
{
  ...
}
```

**【规则】函数调用入参列表应放在一行，超出行宽换行时，保持参数进行合理对齐。**

函数调用时，函数参数列表放在一行。参数列表如果超过行宽，需要换行并进行合理的参数对齐。 左圆括号总是跟函数名，右圆括号总是跟最后一个参数。

换行举例：

```C++
ReturnType result = FunctionName(paramName1, paramName2);   // Good：函数参数放在一行

ReturnType result = FunctionName(paramName1,
                                 paramName2,                // Good：保持与上方参数对齐
                                 paramName3);

ReturnType result = FunctionName(paramName1, paramName2, 
    paramName3, paramName4, paramName5);                    // Good：参数换行，4 空格缩进

ReturnType result = VeryVeryVeryLongFunctionName(           // 行宽不满足第1个参数，直接换行
    paramName1, paramName2, paramName3);                    // 换行后，4 空格缩进
```

如果函数调用的参数存在内在关联性，按照可理解性优先于格式排版要求，对参数进行合理分组换行。

```C++
// Good：每行的参数代表一组相关性较强的数据结构，放在一行便于理解
int result = DealWithStructureLikeParams(left.x, left.y,     // 表示一组相关参数
                                         right.x, right.y);  // 表示另外一组相关参数
```

**【规则】函数名之后不留空格，紧跟左括号`(`。**

**【规则】函数定义结束后应有一行空行。 **

普通函数

```c++
float CalcRectangleArea(float length, float width)
{
    float area;
    
    area = length * width;
    return area;
}

```

类成员函数/类方法

```C++
float Box::CalcRectangleArea(void)
{
    return length * width;
}

```


# 2 命名

## 2.1 通用规则

**【原则】标识符命名应当简洁明确，可望文知意。**

标识符名称最好采用英文单词的组合，不要用汉语拼音，更不要中英混合，用词应当简单准确。

**【原则】标识符名称需满足*最小长度-最大信息量*原则。**

标识符名称需明确表达标识符的含义，一般来说，长的名称能更好的表达含义，但并不是越长越好。

**【规则】除了常见的通用缩写外，不使用单词缩写。**

较短的单词可通过去掉“元音”形成缩写，较长的单词可取单词的头几个字母形成缩写，一些单词有大家公认的缩写，常用单词的缩写必须统一。协议中的单词的缩写与协议保持一致。对于某个系统使用的专用缩写应该在注视或者某处做统一说明。

| **单词**      | **缩写** |
| ------------- | -------- |
| argument      | arg      |
| buffer        | buf      |
| clock         | clk      |
| command       | cmd      |
| compare       | cmp      |
| configuration | cfg      |
| device        | dev      |
| display       | disp     |
| error         | err      |
| hexadecimal   | hex      |
| increment     | inc      |
| initialize    | init     |
| maximum       | max      |
| message       | msg      |
| minimum       | min      |
| parameter     | param    |
| previous      | prev     |
| register      | reg      |
| semaphore     | sem      |
| statistic     | stat     |
| synchronize   | sync     |
| temp          | tmp      |
|               |          |

**【规则】用正确的反义词组命名具有互斥意义的变量或函数。**

| 正义      | 反义        |
| --------- | ----------- |
| add       | delete      |
| add       | remove      |
| begin     | end         |
| copy      | paste       |
| create    | destroy     |
| first     | last        |
| get       | put         |
| get       | release     |
| get       | set         |
| increment | decrement   |
| insert    | delete      |
| lock      | unlock      |
| min       | max         |
| new       | old         |
| next      | previous    |
| open      | close       |
| send      | receive     |
| show      | hide        |
| source    | destination |
| source    | target      |
| start     | stop        |
| up        | down        |

**【规则】禁止无意义的字母加数字命名。**

为了防止程序员偷懒，不肯为命名动脑筋而产生无意义的名字，因此禁止字母加数字的无意义命名。

```C++
int a1;   // 不好的命名
int a2;   // 不好的命名
int aaa;  // 不好的命名
int a123; // 不好的命名
```

**【规则】标识符命名不能以“\_”开头结尾，也不能出现两个连续的“\_”。**

**【规则】程序中不能出现仅仅依赖大小写区分的名称。**

仅仅依赖大小写区分的名称难以区分，容易混淆，例如，

```C++
int x;
int X;
```

**【规则】标识符（内部的和外部的）的有效字符不能多于31。**

ISO 标准要求在内部标识符之间前31个字符必须是不同的，外部标识符之间前6 个字符必须是不同的（忽略大小写）以保证可移植性。我们这里放宽了此要求，要求内部、外部标示符的有效字符不能多于31即可。这样主要是便于编译器识别，代码清晰易读，并保证可移植性。

## 2.2 常见的命名法

目前常见的命名法有三种：驼峰命名法、unix like命名法和匈牙利命名法。

**驼峰命名法 **

驼峰命名法又分为大驼峰法和小驼峰法。

大驼峰命名首字母大写，并且后面的每个单词首字母大写，例如MaxValue，CurrentTime。大驼峰命名法又称为帕斯卡命名法。

小驼峰命名法和大驼峰类似，只是首字母小写，例如maxValue，currentTime。

**unix like命名法 **

此命名法所有单词字母均小写，并且用下划线分隔开，例如max_value，current_time。在UNIX/LINUX这样的环境，以及GNU代码中使用非常普遍。

**匈牙利命名法**

匈牙利命名法由1972年至1981年在施乐帕洛阿尔托研究中心工作的程序员查尔斯·西蒙尼发明。匈牙利命名法分为系统型匈牙利命名法和应用型匈牙利命名法。系统命名法与应用命名法的区别在于前缀的目的。

在系统匈牙利命名法中，前缀代表了变量的实际数据类型。例如：

- `lAccountNum`：变量是一个**长整数**（"l"）;
- `arru8NumberList`：变量是一个**无符号8位整型数组**（"arru8"）;
- `szName`：变量是一个**零结束字符串**（"sz"），这是西蒙尼最开始建议的前缀之一。

匈牙利应用命名法不表示实际数据类型，而是给出了变量**目的**的提示，或者说它代表了什么。

- `rwPosition`：变量代表一个**行**（"rw"）。
- `usName`：变量代表一个**非安全字符串**（"us"），需要在使用前处理。
- `strName`：变量代表一个包含名字的字符串（"str"）但是没有指明这个字符串是如何实现的。

西蒙尼建议的大多数前缀都是自然语义的，但不是所有。下面几个是来自原始论文的：

- `pX`是指向另一个**X**类型的指针，这包含非常少的语义信息。
- `d`是一个前缀表示两个值的差，例如，**dY**可能代表一个图形沿Y轴的距离，而一个仅仅叫做**y**的变量可能是一个绝对坐标。这完全是自然语义的。
- `sz`是一个无结束或零结束的字符串。在C中，这包含一些语义信息，因为C语言的**char\***类型的变量不确定是一个指向单个字符的指针，还是一个字符数组，或是一个零结束字符串。
- `w`标记一个变量是一个字。这基本上没有包含什么语义信息，因此可以被看作一种系统匈牙利命名法。
- `b`标记了一个字节，和w对比可能有一些语义信息，因为C语言中，只有**char**型（以及signed/unsigned char)是一个字节长的，这些类型有时候被用来保存数值或字符。这个前缀可以明确某个变量保存的是字符还是数值。

由于这种命名法通常使用小写字母开头用来助记，但是并没有对助记符本身作规定。有几种被广泛使用的习惯（见下面的示例），但是任意字母组合都可以被使用，只要它们在代码主体中保持一致就可以了。

在使用匈牙利应用命名法的代码中有时候也可能包含系统匈牙利命名法，即在描述被单独以类型方式定义的变量时使用。

**示例**

- `bBusy`：[布尔型]
- `cApples`：项目计数
- `dwLightYears`：双[字]（系统）
- `fBusy`：[布尔型]或[浮点型]
- `nSize`：[整型]（系统）或计数（应用）
- `iSize`：[整型]（系统）或索引（应用）
- `fpPrice`：[浮点数]
- `dbPi`：[双精度浮点数]（系统）
- `pFoo`：[指针]
- `rgStudents`：数组或范围
- `szLastName`：零结束字符串
- `u32Identifier`：无符号32位[整型]（系统）
- `stTime`：时钟结构
- `fnFunction`：函数名

对于指针和[数组]来说，它们实际上并不是数据类型，因此通常在助记符后面跟着实际元素的类型。

- `pszOwner`：指向零结束字符串的指针
- `rgfpBalances`：[浮点]值的数组

尽管匈牙利命名法可以被应用在任何程序设计语言和环境中，由于[微软]在C语言项目中，特别是在[Microsoft Windows]里的大量应用，使得匈牙利命名法的应用大量存在于和Windows相关的领域：

- `hwndFoo`：窗口句柄
- `lpszBar`：指向零结束字符串的长指针

这种命名法又是在[C++]中被扩展而包含变量的[作用域]，由一个下划线隔开：

- `g_nWheels`：全局名字空间的成员，整型
- `m_nWheels`：结构体／类成员，整型

**匈牙利命名法的优点 **

（其中一些只适用于系统匈牙利命名法）

- 不需要[集成开发环境]的支持，从名字中就可以看出变量的类型
- 拥有类似语义的多个变量可以在一个代码块中使用：dwWidth，iWidth，fWidth，dWidth
- 变量名在仅仅知道他们的类型时可以被轻易记住
- 可以使变量名更加一致
- 决定一个变量名的时候可以更机械化，更快
- 不合适的类型转换和操作可以在阅读代码的时候被检测出来，而不需要编译器的检测
- 在那些数字被当作字符串处理的基于字符串的语言中非常有用
- 在匈牙利应用命名法中，变量名确保不会犯以下错误：

​        heightWindow = window.getWidth()

- 在使用[动态类型语言]或完全无类型的语言编程时，关于类型的修饰可以更简化。这种语言一般不包含类型修饰（或者可选），因此唯一可以看出哪些类型是被允许的只有名字本身、文档以及通过阅读代码来明白它们在做什么。在这些语言中，包含对于变量类型的指示可能会有助于程序员。就像上面提到的，匈牙利命名法扩展了这样的语言（BCPL）。
- 在包含许多全局对象的复杂程序中（VB/Delphi Forms），拥有一个基本的前缀命名法可以简化在编辑器中查找组件的工作。按`btn<Ctrl-Space>`可以使编辑器弹出一个Button对象的列表。

**匈牙利系统命名法的缺点 **

- 匈牙利命名法在编译器做类型检查时是多余的。一个提供类型检查的语言在确定一个变量与其类型一致时，比人眼仅仅检查变量的用法与变量名一致要强大的多。
- 一些现代的[集成开发环境]，如[Visual Studio]在需要时可以显示变量类型，并且自动标记不匹配的类型。使用这种命名法完全没有必要。
- 向标识符添加类型标识导致标识符冗长；同时纵容相同主体名而不同类型的变量导致的歧义，开发人员无法从`sWidth`、`nWidth`、`fWidth`中了解这几个Width的用法区别，更好的写法可能是`string input`、`int width`、`float zoomedWidth`。
- 匈牙利命名法在被用作代表多个属性的时候会造成困惑，如 `a_crszkvc30LastNameCol`：一个常量[参数]，保存了一个[varchar]（30）类型的[数据库]列`LastName`的内容，而这列又是这个表的[主键]的一部分。
- 在代码更改后可能造成不一致。如果一个变量的类型改变了，不是变量名的修饰与新的类型不一致，就是变量名必须被改变。
- 由于变量名和类型捆绑在一起，因此不利于代码的移植。一个典型的众所周之的例子就是WPARAM类型，以及在许多Windows系统函数声明中使用的wParam参数。它原本是一个16位的类型，但是在后来的操作系统中被改成了32位或64位，但仍保留原来的名字（它实际的基础类型是UINT_PTR，即一个大小足够保存一个指针的无符号整型）。
- 大多数时候，看到一个变量就意味着知道了它的类型。但是，如果你不知道一个变量是干什么的，知道了它的类型也没什么帮助。

.NET Framework，微软新的软件开发平台，除了接口类型一般不适用匈牙利命名法。在.NET中，习惯在接口类型前放一个`I`（例如Windows Forms中的`IButtonControl`接口。）.NET Framework指导方针建议程序员不要用匈牙利命名法，但是没有指明不要用系统匈牙利命名法还是匈牙利应用命名法，或者是两者都不要用。与此对比，Java的标准库中连接口类型也不加前缀。

## 2.3 文件命名

**【建议】文件命名采用全小写字母，不同单词可用下划线分隔。**

因为不同系统对文件名大小写处理会不同（如MS的DOS、Windows系统不区分大小写，但是Linux系统则区分），所以代码文件命名建议统一采用全小写字母命名。 

**【规则】C源文件以`.c`结尾，C++源文件以`.cpp`结尾，头文件以`.h`结尾。**

推荐使用.h作为头文件的后缀，这样头文件可以直接兼容C和C++。 使用.cpp作为实现文件的后缀，这样可以直接区分C++代码，而不是C代码。

**【建议】C++文件名和类名保持一致。**

C++的头文件和cpp文件名和类名保持一致，使用下划线小写风格。

如下：

- database_connection.h
- database_connection.cpp

结构体，命名空间，枚举等定义的文件名类似。

## 2.4 宏命名

**【规则】宏定义标识符所有字母均大写，不同单词间用下划线分隔。**

```C++
#define PI 3.14159265f
#define SQUARE_AREA(r) ((r)*(r))
```

**【规则】除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线"_"开头和结尾。 **

一般来说，以“_”或“__”开头、结尾的标识符为系统保留或者标准库使用。

## 2.5 命名空间

**【规则】命名空间名称采用全小写字母。**

```C++
namespace project_namespace_name
{
   // 代码声明
}
```

## 2.6 数据类型命名

**【规则】类类型，结构体类型，枚举类型，联合体类型等类型定义名称采用大驼峰法。**

```c++
struct RectifierFaultGroup
{
    int softstartAbnormal;
    int busHighVolt;
    ......
};

class Rectifier
{
    ......    
};
```

**【规则】类、结构体和联合体中的成员变量命名采用小驼峰法。**

## 2.7 常量命名

**【规则】常量名所有字母均大写，不管是宏常量、*const*常量还是枚举，不同单词间用下划线分隔。**

```C++
#define PI 3.14159265f
const int DAYS_IN_A_WEEK = 7;
```

**【规则】常数定义时，十六进制数的A~F全大写。**

```C++
#define FAULT_MASK 0x000E
```

## 2.8 变量命名

变量名最重要的要求是准确简洁地说明变量的用途含义。

**【规则】变量名采用小驼峰法，第一个字母小写，后面每个单词首字母大写，其余均小写。**

```C++
int   points;
int   maxValue;
float busVoltAvg; // 母线电压平均值
```

**【规则】变量的名称应该是“名词”或“形容词+名词”。**

```C++
int currentTime;
int time;
```

**【规则】用正确的反义词组命名具有互斥意义的变量。**

```c++
int minValue;
int maxValue;
```

**【规则】禁止单字母作为变量名，除*i，j，k*作为局部循环变量外。**

```C++
int a;   // 不好的命名
```

**【规则】静态变量加前缀s_（static）。**

```C++
void GetObjectNumber(void)
{
    static int s_objectNumber = 0;
    ......    
}
```

**【建议】尽量不使用全局变量，如果必须有，那么全局变量加前缀g_（global）。**

**【建议】类的`private`成员变量加前缀m_（member）。**

## 2.9 函数命名

**【规则】函数名采用大驼峰法。**

```C++
int GetCurrentTime(void)
{
    ......
}
```

**【规则】函数表示行为或动作，函数名应以动词开头，动词或动词+名词。**

例如函数名GetCurrentTime，获取当前时间Get（动词）+CurrentTime（名词，宾语）。

**【规则】用正确的反义词组命名具有互斥意义的函数。**

```C++
float GetTemperature(void)
{
    return m_temperature;
}

void SetTemperature(float temperature)
{
    m_temperature = temperature;
}
```

**【规则】函数参数命名采用小驼峰法，第一个字母小写，后面每个单词首字母大写，其余均小写。**

# 3 注释 #

一般的，尽量通过清晰的架构逻辑，好的符号命名来提高代码可读性；需要的时候，才辅以注释说明。 注释是为了帮助阅读者快速读懂代码，所以要从读者的角度出发，按需注释。

## 3.1 注释规则

**【原则】好的代码本身就是文档，不需注释即可理解。**

代码必须具有可读性，最好的代码本身就是文档，类型和变量命名意义明确比通过注释解释模糊的命名好的多。

**【原则】注释要简洁明确，且在功能、意图层次上解释，着重说明“为什么”，而不是逐行描述代码。**

为了别人理解代码，或者自己理解代码，需要合理添加注释。如何写注释，什么样的注释是好的注释，这是一个非常重要的问题。注释并不是写的越多越好，关键是要说明程序的功能，目的，这就要求注释主要讲为什么，而不是是什么，或者怎么做。

例如，下面的注释完全是多余的，除了浪费码字的时间，占用字符位置，还影响别人读代码。

```c
if (timer > 10)  // 如果timer大于10
{
    i++;  // i加一
}
```

对于代码实现逻辑晦涩或巧妙的代码需着重说明。

例如，下面对定点DSP实现除法代码的注释。

```C
avgCurrent = (totalCurrent * 1365)>>13; // 定点运算，平均电流=总电流/设备数量6台
```

**【规则】注释必须与代码同步更新，无用的注释应删除。**

和代码不能同步的注释，不仅没有解释代码，起到帮助别人理解代码的作用，更多情况反而会误导读者，所以修改代码的同时必须更新相应的注释。

**【建议】单行注释使用//，多行注释使用/\* \*/ **

**【规则】注释/\* \*/不可嵌套使用。 **

**【规则】注释符号//、/\*、\*/与注释内容之间有一个空格，右置注释与前面代码至少1空格。**

**【规则】注释应位于相应代码的上方或右方。**

注释写在相应代码的右边或上面，紧邻代码，不要太远，例如行尾注释可在代码后空两格添加。**注释位于代码上面时，需与相应代码缩进相同**。

当连续多行代码都有注释时，可以适当调整注释位置使排版美观，可读性更好。

当右置的注释超过行宽时，请考虑将注释置于代码上方。

例如，注释位于代码右边。

```C
int voltOverLow;  // 电压过低标志
```

例如，注释位于代码上面。

```C
// 由于通信可能受到干扰，为避免误判通信失败，在此处连续5次异常，才判定通信失败。
if (commAbnormalCnt >= 5)
{
    commFail = true;
}
```

例如，连续多行代码都有注释

```C
struct RecFaultBits
{
    UINT16 fault                :1;  // BIT00 PFC故障汇总标志
    UINT16 hwSoftStartAbnormal  :1;  // BIT01 硬件软起异常
    UINT16 swSoftStartAbnormal  :1;  // BIT02 软件软起异常
    UINT16 dcVoltLow            :1;  // BIT03 直流母线低压
    UINT16 rsvd                 :12; // BIT04-15 保留
};
```

**【建议】文件头部注释应列出文件内容说明、作者姓名/工号、创建日期、版本号、版权信息、修改日志等。**

文件注释列出作者姓名工号便于后来的代码阅读者在有疑问时找到原作者沟通问题。

文件头部注释示例如下：

```C
/**
* @file       filename
* @brief      This is a brief description.
* @details    This is the detail description.
* @author     Felix Lu/000011
* @date       2019-02-14
* @version    V00A00D00
* @par Copyright (c) 2019~2100, 西安图为电气技术有限公司. All rights reserved.
* @par History:
*             version: author, date, desc
*/
```

**【建议】函数声明处注释描述函数的功能、用法、输入输出参数返回值，以及对参数的限制和注意事项；函数定义处着重说明函数解决的问题和实现思路。**

示例如下

```C
/**
 * @brief   该函数的简要说明
 * @details 该函数的详述信息
 * @param a param描述参数
 * @return  return描述返回值
 * @note    note描述需要注意的问题
 */
```

**【建议】类数据成员、全局变量和常量应注释说明含义及用途。**

首先，变量名本身应该能够明确说明变量的用途。特定情况下，需要额外注释。

类数据成员（成员变量）应注释说明用途，或注意事项。

例如：

```C
class CUtility
{
 public:
    float uin;     // 市电电压
    ...
 private:
    float freqFlt;  // 市电频率滤波值，用于监控显示
    ...
};
```

全局变量和常量，应注释说明含义及用途。

例如：

```C
const float GRID_FREQ = 50.0f;  // 电网频率
```

**【规则】避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写。**

**【规则】同一产品统一注释风格。**

**【建议】不要在一行代码或表达式中间插入注释。**

**【建议】多行注释在合理的位置分行。**

**【建议】TODO注释后添加自己的姓名工号。**

对于临时的或者需要继续完善的实现代码，可添加TODO注释，并在后面括号()中写上你的名字工号，还可以加上冒号：说明待完成的工作。

例如

```C++
// TODO(Felix Lu/000011): 此处故障检测方法太灵敏，需优化。
```

**【建议】注释用自己熟悉的语言书写。**

如果英语水平不行，写注释与其用语句不通的英语，不如用信手拈来的汉语。

**【规则】注释采用Doxygen格式书写。**

Doxygen是一种开源跨平台的，以类似JavaDoc风格描述的文档系统，完全支持C、C++、Java、Objective-C和IDL语言，部分支持PHP、C#。注释的语法与Qt-Doc、KDoc和JavaDoc兼容。Doxygen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。

因此，在写注释时按照Doxygen的格式书写，便于生成代码参考手册。

## 3.2 Doxygen注释种类

Doxygen注释的种类有多种

1.

```c++
/**
 * ....描述...
*/
```

2.

```c++
/*!
 * ....描述...
*/
或者
/*!
  ....描述...
*/
```

3.

```c++
///
///....描述...
///
或者
//!
//!....描述...
//!
```

### 文件注释 ###

```c
/**
* @file       filename
* @brief      This is a brief description.
* @details    This is the detail description.
* @author     Felix Lu/000011
* @date       2019-02-14
* @version    V00A00D00
* @par Copyright (c) 2019~2100, 西安图为电气技术有限公司. All rights reserved.
* @par History:
*             version: author, date, desc
*/
```

### 函数注释 ###

```C
/**
 * @brief   该函数的简要说明
 * @details 该函数的详述信息
 * @param a 被测试的变量（param描述参数）
 * @param b 被测试的另一变量的描述
 * @return  测试结果（return描述返回值）
 * @note    (note描述需要注意的问题)
 */
int DoNothing(int a, float b);
```

### 宏定义注释

```c++
/** Description of the macro */
#define XXXX_XXX_XX      ox7fffffff
```

或者

```c++
#define XXXX_XXX_XX      0  ///< Description of the macro.
```

### 结构体注释

```c++
/**
 * The brief description.
 * The detail description.
 */
typedef struct
{
    int var1;     ///< Description of the member variable
}XXXX;
```

或者

```c++
typedef struct Box
{
    double length; ///< The length of the box
    double width;  ///< The width of the box
    double height; ///< The height of the box
};
```

enum的各个值也如上注释。

### 变量注释

```c++
//! 简述
//! 详细描述
//! 从这里开始
int var; ///< 变量var说明
```

### 全局和静态变量注释

```c++
/**  Description of global variable  */
int g_xxx = 0;
static int s_xxx = 0; ///<  Description of static variable
```

### Doxygen指令说明 ###

| 指令       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| @file      | 档案的批注说明。                                             |
| @author    | 作者的信息                                                   |
| @brief     | 用于class 或function的简易说明。eg：@brief 本函数负责打印错误信息串 |
| @param     | 主要用于函数说明中，后面接参数的名字，然后再接关于该参数的说明。eg：@param arg_name 参数说明 |
| @return    | 描述该函数的返回值情况。eg：@return 本函数返回执行结果，若成功则返回TRUE，否则返回FLASE |
| @retval    | 主要用于函数说明中，描述返回值类型和意义，所以后面要先接一个返回值，然后再放该返回值的说明。eg：@retval NULL 空字符串。 @retval !NULL 非空字符串。 |
| @note      | 注解                                                         |
| @attention | 注意                                                         |
| @warning   | 警告信息                                                     |
| @enum      | 引用了某个枚举，Doxygen会在该枚举处产生一个链接。eg：@enum CTest::MyEnum |
| @var       | 引用了某个变量，Doxygen会在该变量处产生一个链接。eg：@var CTest::m_FileKey |
| @class     | 引用某个类，格式：@class <name> [<header-file>][]。eg：@class CTest "inc/class.h" |
| @exception | 可能产生的异常描述。eg：@exception 本函数执行可能会产生超出范围的异常 |



# 4 预处理

**【规则】匹配的预处理语句`#if`、`#else`、`#elseif`、`#endif`不应被分散在不同的文件之中。**

**【规则】`#if`表达式中使用的宏应该已经被定义，并且`#if`表达式只能包含整型常量。**

```C++
// 不规范用法示例
#define BIGINT 32767
#define BIGREAL 1e38
#if(BIGREAL>BIGINT)
...
#endif
```



# 5 文件

## 5.1 头文件

头文件是模块或文件的对外接口，头文件的设计体现了大部分的系统设计。 头文件中适合放置接口的声明，不适合放置实现（内联函数除外）。对于cpp文件中内部才需要使用的函数、宏、枚举、结构定义等不要放在头文件中。 头文件应当职责单一。头文件过于复杂，依赖过于复杂还是导致编译时间过长的主要原因。

**【建议】每一个.cpp/.c文件应有一个对应的.h文件，用于声明需要对外公开的类与接口。**

通常情况下，每个.cpp文件都有一个相应的.h，用于放置对外提供的函数声明、宏定义、类型定义等。 如果一个.cpp文件不需要对外公布任何接口，则其就不应当存在。

```C++
// Foo.h 
#ifndef FOO_H
#define FOO_H

class Foo
{
 public:
    Foo();
    void Fun();

 private:
    int value;
};

#endif
```

```C++
// Foo.cpp
#include "Foo.h"

// Good:对内函数的声明放在.cpp文件的头部，并声明为匿名namespace或者static限制其作用域
namespace 
{ 
    void Bar()
    {
    }
}

...

void Foo::Fun()
{
    Bar();
}
```

**【规则】头文件用于声明模块对外接口，包括具有外部链接的函数原型声明、全局变量声明、定义的类型声明等。**

头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。

内部使用的函数声明不应放在头文件中。 内部使用的宏、枚举、结构定义不应放入头文件中。变量定义不应放在头文件中，应放在.c/.cpp文件中。

 变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。即使必须使用全局变量，也只应当在.c/.cpp中定义全局变量，在.h中仅声明变量为全局的。

**【规则】头文件中只放对象或函数的声明，不放对象或函数的定义。**

如果在头文件中定义对象，将会由于头文件被其它源文件包含而导致对象重复定义。

**【规则】使用#define定义保护符，防止头文件重复包含。**

多次包含一个头文件可以通过认真的设计来避免。如果不能做到这一点，就需要采取阻止头文件内容被包含多于一次的机制。

通常的手段是为每个文件配置一个宏，当头文件第一次被包含时就定义这个宏，并在头文件被再次包含时使用它以排除文件内容。所有头文件都应当使用#define 防止头文件被多重包含，命名格式FILENAME_H，其中FILENAME 为头文件的名称，为了保证唯一性，更好的命名是PROJECTNAME_PATH_FILENAME_H。

定义包含保护符时，应该遵守如下规则： 

1. 保护符使用唯一名称； 

2. 不要在受保护部分的前后放置代码。 

```C++
#ifndef FILENAME_H
#define FILENAME_H

......

#endif
```

**【规则】禁止头文件循环依赖。**

头文件循环依赖，指 a.h 包含 b.h，b.h 包含 c.h，c.h 包含 a.h， 导致任何一个头文件修改，都导致所有包含了a.h/b.h/c.h的代码全部重新编译一遍。
而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h/c.h的源代码重新编译。

头文件循环依赖直接体现了架构设计上的不合理，可通过优化架构去避免。

**【规则】禁止包含用不到的头文件。**

用不到的头文件被包含的同时引入了不必要的依赖，增加了模块或单元之间的耦合度，只要该头文件被修改，代码就要重新编译。

很多系统中头文件包含关系复杂，开发人员为了省事起见，直接包含一切想到的头文件，甚至发布了一个god.h，其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦。

**【规则】头文件应当自包含。**

简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，给这个头文件的用户增添不必要的负担。

示例： 如果a.h不是自包含的，需要包含b.h才能编译，会带来的危害： 每个使用a.h头文件的.cpp文件，为了让引入的a.h的内容编译通过，都要包含额外的头文件b.h。 额外的头文件b.h必须在a.h之前进行包含，这在包含顺序上产生了依赖。

**【规则】禁止在extern "C"中包含头文件。**

在 extern "C" 中包含头文件，有可能会导致 extern "C" 嵌套，部分编译器对 extern "C" 嵌套层次有限制，嵌套层次太多会编译错误。

在C，C++混合编程的情况下，在extern "C"中包含头文件，可能会导致被包含头文件的原有意图遭到破坏，比如链接规范被不正确地更改。

示例，存在a.h和b.h两个头文件：

```C++
...
#ifdef __cplusplus
void Foo(int);
#define A(value) Foo(value)
#else
void A(int)
#endif
```

```C++
...
#ifdef __cplusplus
extern "C"
{
#endif

#include "a.h"
void B();

#ifdef __cplusplus
}
#endif
```

使用C++预处理器展开b.h，将会得到

```C++
extern "C"
{
    void Foo(int);
    void B();
}
```

按照 a.h 作者的本意，函数 Foo 是一个 C++ 自由函数，其链接规范为 "C++"。 但在 b.h 中，由于 `#include "a.h"` 被放到了 `extern "C"` 的内部，函数 Foo 的链接规范被不正确地更改了。

例外： 如果在 C++ 编译环境中，想引用纯C的头文件，这些C头文件并没有`extern "C"` 修饰。非侵入式的做法是，在 `extern "C"` 中去包含C头文件。

**【建议】头文件包含顺序：首先是.cpp相应的.h文件，其它头文件按照稳定度排序。**

使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖，建议按照稳定度排序：cpp对应的头文件, C/C++标准库, 系统库的.h, 其他库的.h, 本项目内其他的.h。

举例，Foo.cpp中包含头文件的次序如下:

```C++
#include "Foo/Foo.h"

#include <cstdlib>
#include <string>

#include <linux/list.h>
#include <linux/time.h>

#include "platform/Base.h"
#include "platform/Framework.h"

#include "project/public/Log.h"
```

将Foo.h放在最前面可以保证当Foo.h遗漏某些必要的库，或者有错误时，Foo.cpp的构建会立刻中止，减少编译时间。 对于头文件中包含顺序也参照此建议。

例外： 平台特定代码需要条件编译，这些代码可以放到其它 includes 之后。

```C++
#include "foo/public/FooServer.h"

#include "base/Port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include <initializer_list>
#endif  // LANG_CXX11
```



## 5.2 源文件

**【规则】只能通过包含头文件的方式使用其它模块提供的接口，禁止在.c/.cpp中通过extern的方式使用外部函数接口、变量。**

不符合规范的例子

```C++
// a.cpp内容
extern int Fun();   // Bad: 通过extern的方式使用外部函数

void Bar()
{
    int i = Fun();
    ...
}
```

```C++
// b.cpp内容
int Fun()
{
    // Do something
}
```

应该改为

```C++
// a.cpp内容
#include "b.h"   // Good: 通过包含头文件的方式使用其他.cpp提供的接口

void Bar()
{
    int i = Fun();
    ...
}
```

```C++
// b.h内容
int Fun();
```

```C++
// b.cpp内容
int Fun()
{
    // Do something
}
```

例外，有些场景需要引用其内部函数，但并不想侵入代码时，可以 extern 声明方式引用。 如： 针对某一内部函数进行单元测试时，可以通过 extern 声明来引用被测函数； 当需要对某一函数进行打桩、打补丁处理时，允许 extern 声明该函数。

**【建议】一个源文件中的程序总行不宜超过2000行。**

**【建议】源文件中的废弃代码应及时删除。**

不用的代码段不要注释掉，应直接删除。被注释掉的代码，无法被正常维护；当企图恢复使用这段代码时，极有可能引入易被忽略的缺陷。 正确的做法是，不需要的代码直接删除掉。若再需要时，考虑移植或重写这段代码。

**【规则】源文件中不应存在执行不到的代码。**

可能由于条件错误或者条件不可能满足而导致一些代码执行不到，需检查审视。

# 6 宏

**【规则】用宏定义表达式必须要有完备的括号。**

因为宏只是在预处理过程中进行简单的替换。

如下的定义都是有风险的

```c++
#define POWER(VOLT, CURRENT) VOLT*CURRENT
#define POWER(VOLT, CURRENT) (VOLT*CURRENT)
#define POWER(VOLT, CURRENT) (VOLT)*(CURRENT)
```

如果使用上面第一种宏表达式写法，在使用 POWER(a+b, c+d) 将会展开为 a+b * c+d，导致错误发生。

正确的写法应当是

```c++
#define POWER(VOLT, CURRENT) ((VOLT)*(CURRENT))
```

表达式整体以及参数都必须加上括号。

**【规则】宏定义的多条表达式应放在{}中。**

更好的方法是多条语句写成 do while(0) 的形式。

例如：有下面的宏定义表达式

```c++
#define UPDNLMT(var,max,min) (var)=((var)>=(max))?(max):(var); \
                             (var)=((var)<=(min))?(min):(var);
```

当如下方式使用时

```c++
for (int i=0; i<1000; i++)
    UPDNLMT(var,1024,-1024)
....
```

会导致循环中只有宏表达式的第一句执行。加上{}后可以解决这一问题。

```C++
#define UPDNLMT(var,max,min) {(var)=((var)>=(max))?(max):(var); \
                             (var)=((var)<=(min))?(min):(var);}
```

上面示例中，宏表达式可正常作用。但是，如果在调用宏表达式时后面加上分号，仍会出现错误

```c++
if (flag == 1)
    UPDNLMT(var,1024,-1024);
else
    UPDNLMT(var,10,-10);
```

编译器会提示编译错误。

所以使用do while(0)方式定义宏表达式更好一些。

**【规则】使用宏表达式时，参数不允许变化。**

```c++
#define SQUARE_AREA(r) ((r)*(r))
...
a = 1;
SQUARE_AREA(a++)
```

在宏使用时，看上去a自增一次，实际结果是a增加了两次变成3，因为宏展开后为  ((a++)*(a++))。

同时建议即使函数调用，也不要在参数中做变量变化操作，因为可能引用的接口函数，在某个版本升级后，变成了一个兼容老版本所做的一个宏，结果可能不可预知。

**【规则】不允许直接使用魔鬼数字**

使用魔鬼数字会导致代码难以理解。如果一个有含义的数字多处使用，一旦需要修改这个数值，需要逐个查找更改，代价惨重。使用明确意义的名称能增加信息，并能提供单一的维护点。

解决途径：对于局部使用的唯一含义的魔鬼数字，可以在代码周围增加说明注释，也可以定义局部const变量，变量命名自注释。

对于广泛使用的数字，必须定义const全局变量/宏；同样变量/宏命名应是自注释的。

0作为一个特殊的数字，作为一般默认值使用没有歧义时，不用特别定义。

**【建议】除非必要，应尽可能使用函数代替宏。**

 宏对比函数，有一些明显的缺点：

1.宏缺乏类型检查，不如函数调用检查严格。

2.宏展开可能会产生意想不到的副作用，如#define SQUARE(a) ((a) * (a)) 这样的定义，如果是SQUARE(i++)，就会导致i被加两次，如果是函数调用int square(int a) {return a * a;}则不会有此副作用。

3.以宏形式写的代码难以调试难以打断点，不利于定位问题。

4.宏如果调用的很多，会造成代码空间的浪费，不如函数空间效率高。 

示例：下面的代码无法得到想要的结果：

```C++
#define MAX_MACRO(a, b) ((a) > (b) ? (a) : (b))

int MaxFunc(int a, int b) 
{
    return ((a) > (b) ? (a) : (b));
}

int TestFunc()
{
    unsigned int a = 1;
    int b = -1;
    printf("MACRO: max of a and b is: %d\n", MAX_MACRO(++a, b));
    printf("FUNC : max of a and b is: %d\n", MaxFunc(a, b));
    return 0;
}
```

上面宏代码调用中，结果是(a < b)，所以a只加了一次，所以最终的输出结果是：

```
MACRO: max of a and b is: -1
FUNC : max of a and b is: 2
```

**【建议】常量建议使用*const*定义代替宏。**

  “尽量用编译器而不用预处理”，因为#define经常被认为好象不是语言本身的一部分。看下面的语句：

```C++
 #define ASPECT_RATIO 1.653 
```

编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。解决这个问题的方案很简单：不用预处理宏，定义一个常量：

```c
const double ASPECT_RATIO = 1.653;
```

 这种方法很有效，但有两个特殊情况要注意。首先，定义指针常量时会有点不同。因为常量定义一般是放在头文件中（许多源文件会包含它），除了指针所指的类型要定义成const外，重要的是指针也经常要定义成const。例如，要在头文件中定义一个基于char*的字符串常量，你要写两次const：

```
const char * const authorName = "Scott Meyers";
```

**【建议】宏定义中尽量不使用*return*、*goto*、*continue*、*break*等改变程序流程的语句**

 如果在宏定义中使用这些改变流程的语句，很容易引起资源泄漏问题，使用者很难自己察觉。 

示例：在某头文件中定义宏CHECK_AND_RETURN：

```
#define CHECK_AND_RETURN(cond, ret) {if (cond == NULL_PTR) {return ret;}}
```

 然后在某函数中使用(只说明问题，代码并不完整)：

```c
pMem1 = VOS_MemAlloc(...); 
CHECK_AND_RETURN(pMem1 , ERR_CODE_XXX) 
pMem2 = VOS_MemAlloc(...); 
CHECK_AND_RETURN(pMem2 , ERR_CODE_XXX) /*此时如果pMem2==NULL_PTR，则pMem1未释放函数就返回了，造成内存泄漏。*/
```

所以说，类似于CHECK_AND_RETURN这些宏，虽然能使代码简洁，但是隐患很大，使用须谨慎。

# 7 数据类型

**【规则】不应使用基本数据类型char、int、short、long、float和double，而应使用typedef重新进行类型的定义，并标明数据长度和符号。**

各个平台的数据长度可能不一样，例如有些平台int是16位，有些是32位，有些平台char是8位，有些是16位。为了跨平台的可移植性，应根据硬件平台和编译器的信息，使用typedef定义指明了数据长度和符号的数据类型。

```C++
typedef unsigned char BOOL;
typedef char          CHAR;
typedef unsigned char UCHAR;
typedef int           INT16;
typedef long          INT32;
typedef unsigned int  UINT16;
typedef unsigned long UINT32;
typedef float         FLOAT32;
typedef long double   FLOAT64;
```

避免滥用typedef或者#define对基本类型起别名，不要使用 #define 进行别名定义，并且在C++11以后推荐使用using来定义类型。

```C++
// 滥用举例
typedef uint16_t MyCounter;
// ...
int Foo(...) {
  MyCounter c;
  // ...
  while (c >= 0) {
    printf("counter = %d\n", c);
    // ...
  }
  // ...
}
```

对类型“MyCounter”是否可能小于0，打印时用'%d'还是'%u'都不是很直观，极容易引入上述类似缺陷。

**【原则】应减少不必要的数据类型默认转换与强制转换。**

**【规则】表达式如果是函数的参数或者函数的返回表达式，不能出现默认数据类型转换。**

**【规则】类型强制转换必须明确转换前后的数值表示范围。**

这条规则主要是要求需要强制转换时，须明确被转换对象的表示范围及转换后的表示范围。在程序中尽量规划好变量范围，尽量少使用强制转换。

**【规则】禁止signed类型与unsigned类型之间的隐式转换。**

有符号数转换成无符号数可能导致符号丢失，无符号数转为有符号数可能得到一个负值。

**【规则】禁止int类型与float类型之间的隐式转换。**

浮点型与整型之间转换会导致精度丢失。

**【建议】后缀“U”/“u”应该用在所有unsigned类型的常量上。**

**【规则】不应对指针变量使用强制类型转换赋值。**

```C++
// 不规范代码示例
void GiveAnExample(void)
{
    unsigned short var = 0;
    unsigned int *ptr;
    
    ptr = (unsigned int *)var;
}
```

**【建议】考虑到程序的可移植性，尽量不使用位域。**

位域的使用主要出现在如下两种情况：

* 当机器可用内存空间较少而使用位域可以大量节省内存时。如，当把结构作为大数组的元素时。

* 当需要把一结构或联合映射成某预定的组织结构时。例如，当需要访问字节内的特定位时。

位域使用要注意以下几点：

* 当要把某个成员说明成位域时，其类型只能是int，unsigned int与signed int三者之一(说明：int类型通常代表特定机器中整数的自然长度，short类型通常为16位，long类型通常为32位，int类型可以为16位或32位，各编译器可以根据硬件特性自主选择合适的类型长度。见The C Programming Language中文 P32)。
* int值不能跨字存放，同样位域也最好不要跨字存放(意思是说：各位域的分配位数加起来要在16位或32位以内，如果编译器分配int为16位，则加起来要在16位以内，如果加起来大于16位，则最好空出剩余的位域，从下一个字开始分配位域)。
* 位域的长度不能大于int对象所占用的字位数。例如，若int对象占用16位，则如下位域说明是错误的

```C++
unsigned int x:17;
```

* 特殊宽度0或者说长度为0的无名位域有着特殊的用途。它用于指示将其前后的两个位域或成员分开放在两个字中，即将位于该无名位域后的下一个位域从下一个字开始存放。
* 带位域的结构在内存中各个位域的存储方式取决于具体的编译程序，它们既可以从左到右，也可以从右到左存储。使用位域会影响程序的可移植性，所以在不是非要使用位域不可时最好不要使用位域。
* 尽管使用位域可以节省内存空间，但却增加了处理时间，在访问各个位域成员时需要把位域从它所在的字中分解出来或反过来把值压缩存到位域所在的字位中。
* 位域的位置不能访问，因些不能对位域使用地址运算符号&(而对非位域成员则可以使用该运算符)，即不能使用指向位域的指针，也不能使用位域的数组(因为数组实际上就是一种特殊的指针)。另外，位域也不能作为函数返回的结果。
* 位域又叫位段(位字段)，是一种特殊的结构成员或联合成员(即只能用在结构或联合中)。

位域压缩存储的大致规则为（位域的标准类型是int, signed int, unsigned int, 即对齐宽度是sizeof(int))）：

* 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止； 
* 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍； 
*  如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式； 
*  如果位域字段之间穿插着非位域字段，则不进行压缩； 
*  整个结构体的总大小为最宽基本类型成员大小的整数倍。

基于上述规则，为了节省空间，使用位域时首先建议都用unsigned int类型，并且将要用位域的字段单独取出来做一个结构体，将长的位域放后面，短的放前面。

**【规则】位域应明确定义为有符号的还是无符号的。**

**【规则】位域变量赋值，注意不要溢出。**



# 8 常量

常量的值在程序运行期间恒定不变，可以用#define定义宏常量，也可以用const定义常量。

如果不使用常量，直接在程序中填写数字或字符串，将会有什么麻烦？  

1. 程序的可读性（可理解性）变差。程序员自己会忘记那些数字或字符串是什么意思，用户则更加不知它们从何处来、表示什么。  
2. 在程序的很多地方输入同样的数字或字符串，难保不发生书写错误。  
3. 如果要修改数字或字符串，则会在很多地方改动，既麻烦又容易出错。  

 **【原则】不允许使用魔鬼数字。**

所谓魔鬼数字即看不懂、难以理解的数字。

魔鬼数字并非一个非黑即白的概念，看不懂也有程度，需要自行判断。 例如数字 12，在不同的上下文中情况是不一样的： type = 12; 就看不懂，但 `month = year * 12`; 就能看懂。 数字 0 有时候也是魔鬼数字，比如 `status = 0`; 并不能表达是什么状态。

**解决途径**： 对于局部使用的数字，可以增加注释说明；对于多处使用的数字，必须定义 const 常量，并通过符号命名自注释。

禁止出现下列情况： 没有通过符号来解释数字含义，如`const int ZERO = 0` 符号命名限制了其取值。

**【规则】用含义直观的常量来表示在程序中多次出现的数字或字符串。**

```C++
#define PI 3.1415926f
const float HIGH_VOLT 400.0f
```

**【规则】常量应该保证单一职责。**

一个常量只用来表示一个特定功能，即一个常量不能有多种用途。

```C++
// 好的例子：协议A和协议B，手机号(MSISDN)的长度都是20。
const unsigned int A_MAX_MSISDN_LEN = 20;
const unsigned int B_MAX_MSISDN_LEN = 20;
```

**【规则】如果某一常量与其它常量密切相关，应在定义中包含这种关系，而不应给出一些孤立的值。**

```C++
const float RADIUS = 100; 
const float DIAMETER = RADIUS * 2;
```

**【规则】需要对外公开的常量放在头文件中，不需对外公开的常量放在实现文件的头部。为便于管理，可以把不同模块的常量集中存放在一个公共的头文件中。**

**【建议】使用`const`常量代替宏常量。**

const常量有数据类型，而宏常量没有，编译器可以对const常量进行类型安全检查。集成化的调试工具可以对const常量进行调试，但不能对宏常量调试。

**【建议】类中的常量用枚举实现。**

枚举常量不会占用对象的存储空间，它们在编译时被全部求值。枚举常量的缺点是：它的隐含数据类型是整数，其最大值有限，且不能表示浮点数（如 PI=3.14159）。 

```c++
class A 
{
    enum {SIZE1 = 100, SIZE2 = 200}; // 枚举常量 
    int array1[SIZE1];
    int array2[SIZE2]; 
};
```

**【规则】一组相关的整型常量应定义为枚举。**

枚举比#define或const int更安全。编译器会检查参数值是否位于枚举取值范围内，避免错误发生。

**【规则】枚举元素的初始化应完整——如果对枚举元素进行初始化，要么初始化所有元素，要么只初始化第一个元素。**

当枚举值需要对应到具体数值时，须在声明时显式赋值。否则不需要显式赋值，以避免重复赋值，降低维护(增加、删除成员)工作量。

```C++
    // 好的例子
    enum example{NUM1 = 1, NUM2 = 2, NUM3 = 3};
    enum example{NUM1 = 1, NUM2, NUM3};
    // 不好的例子
    enum example{NUM1, NUM2 = 2, NUM3 = 3}
    enum example{NUM1, NUM2 = 2, NUM3}
```

**【规则】使用八进制数必须加以注释说明。**

八进制数以0开始，易与十进制数混淆。

**【建议】对于运行过程中值不改变的变量，宜使用`const`声明为常量。**

# 9 变量

**【规则】所有变量在使用之前必须初始化，可以定义变量的同时初始化变量，避免忘记初始化。**

```C++
int month = 1;
int day = 1;
```

**【建议】变量的名称要与实际用途相符。不要一个变量，多种用途。**

**【规则】程序中不要出现名称完全相同的全局变量和局部变量。**

局部变量与全局变量同名时，会屏蔽全局变量，理论上可以使用，但是由于名称相同，降低了代码的可读性，可能导致代码阅读者理解错误。

**【规则】使用联合类型时，应明确联合的存储细节。**

应了解联合的末尾有多少个填充单位，联合的各个成员如何对齐，以及多字节的数据类型高低字节排列顺序等。

**【规则】不应在局部作用域声明变量时使用extern。**

```C++
// 不良代码示例
int GiveAnExample(void)
{
    extern int x = 0;
    return 0;
}

```

**【建议】字符型变量应明确定义是有符号的还是无符号的。**

**【规则】多线程应用中，被几个任务共享的变量应使用`volatile`。**

# 10 表达式

C/C++中有数十个运算符，优先级与结合律如下表。注意一元运算符 + - * 的优先级高于对应的二元运算符。

![运算符的优先级与结合律](.\picture\运算符的优先级与结合律.png)

**【规则】如果代码中的运算符比较多，用`()`来确保计算顺序，避免使用默认的优先级。**

```C++
    root = (-b + sqrt(b*b-4*a*c)) / (2*a)；  // 求根公式
        
    value = 2;
    result = value >> 2 + 1;  // ?
```

**【规则】逻辑运算符`||`或`&&`的右操作数不能包含副作用。**

逻辑操作符&&或||在进行逻辑判断时，若仅判别左操作数就能确定true或false的情况下，逻辑操作符的右操数将被忽略，如果右操作数存在计算将不会被执行。

```C++
    if (flag || (value == (i++))) // 如果flag为true，i++将不会被执行
    {}
```

**【建议】在一个表达式中，自增（++）和自减（- - ）运算符不应同其它运算符混合使用。**

**【规则】含有变量自增或自减运算的表达式中禁止再次引用该变量。**

含有变量自增或自减运算的表达式中，如果再引用该变量，其结果在C++标准中未明确定义。各个编译器或者同一个编译器不同版本实现可能会不一致。 为了更好的可移植性，不应该对标准未定义的运算次序做任何假设。

注意，运算次序的问题不能使用括号来解决，因为这不是优先级的问题。

举例：

```C++
x = b[i] + i++; // Bad: b[i]运算跟 i++，先后顺序并不明确。
```

正确的写法是将自增或自减运算单独放一行

```C++
x = b[i] + i;
i++;            // Good: 单独一行
```

函数参数

```C++
Func(i++, i);   // Bad: 传递第2个参数时，不确定自增运算有没有发生
```

正确的写法

```C++
i++;            // Good: 单独一行
x = Func(i, i);
```

**【规则】不能在具有副作用的表达式中使用sizeof 运算符。**

当一个表达式使用了sizeof运算符，并期望计算表达式的值时，表达式是不会被计算的。sizeof只对表达式的类型有用。

```C++
    INT16 i;
    INT16 j;

    j = sizeof(i = 1234); // j的值是i类型的大小，但i的值并没有赋值成1234
```

**【建议】不要编写过于复杂的复合表达式。**

**【规则】不应将无格式的字符型变量和无符号变量与负数和零比较。**

无格式的字符型指既没有定义为unsigned也没有定义为signed的char型，不同的编译器对其处理是不一样的，有的定义其可正可负，有的定义其只能为正。

下面示例代码中，1是大于-1的，但是由于varA是无符号，而varB是有符号的，在比较的时候，varB会转换成unsigned int，因此条件不满足，不会执行printf("A > B\n")。

```C++
	unsigned int varA = 1;
	int varB = -1;

	if (varA > varB)
	{
		printf("A > B\n");
	}
```

**【规则】对变量进行移位操作应注意是否产生了溢出或数据截断。**

**【规则】应避免除数可能为0的情况出现。**

**【规则】不应对无符号的表达式进行一元减运算。**

**【建议】 表达式的比较，应当遵循左侧倾向于变化、右侧倾向于不变的原则。**

当变量与常量比较时，如果常量放左边，如 if (MAX == v) 不符合阅读习惯，而 if (MAX > v) 更是难于理解。 应当按人的正常阅读、表达习惯，将常量放右边。



# 11 语句

**【建议】控制结构的嵌套层数应限制在一定范围内。**

## 11.1 if

**【规则】不可将布尔型变量与TRUE、FALSE或者1、0进行比较。**

根据布尔类型的语义，规定0为FALSE，非零为TRUE ，TRUE 的值究竟是什么并没有统一的标准。例如 Visual C++ 将 TRUE 定义为 1，而 Visual Basic 则将 TRUE 定义为-1。

```C++
bool flag;

if (flag) // 正确
{}
if (！flag) // 正确
{}
// 以下都是不良风格
if (flag == 0)
{}
if (flag == 1)
{}
if (flag == TRUE)
{}
if (flag == FALSE)
{}
```

**【规则】不可将浮点变量用`==`或`!=`与任何数字做比较。**

float和double变量都有精度限制，所以必须避免相等或不等的比较，都需要转化为`>=`或`<=`的比较。

例如，需要比较变量value是否为0，应该转化为下面代码

```C++
    #define EPS 0.00001f // 允许误差

    if ((value >= -EPS) && (value <= EPS))
    {}
```

**【规则】判断指针变量是否为空，应将指针变量与NULL进行相等或不等的比较，而不是与0比较。**

```C++
    if (ptr == NULL) // 正确写法
    {}
    
    if (ptr == 0) // 错误写法
    {}
```

**【规则】必须考虑条件是否完整覆盖。**

**【建议】为了避免将`==`误写为`=`，可将常量放到`==`的左边。**

```C++
    if (value == 1) // 正确代码
    {}
    
    if (value = 1)  // 误将“==”写为“=”，编译器不能发现错误
    {}
    
    if (1 = value)  // 误将“==”写为“=”，编译器可以发现错误
    {}
```

## 11.2 switch

**【规则】每一个case分支的结尾必须有break语句，否则匹配一个case后会继续执行下一个case分支，直到遇到break语句或者switch结束（除非编码的目的本就是多case连续执行）。**

```C++
    switch (value)
    {
        case 'A':
            DoA();
            break;
        case 'B':   // 如果value='B'，将会执行DoB()和DoC()。
            DoB();
        case 'C':
            DoC();
            break;
        default:
            break;        
    }
```

**【规则】switch必须有default分支。**

**【建议】为了提高程序效率，应把switch-case语句中的每一种具体情况按照它们发生的相对频率排序，把最可能发生的情况放在最前面，最不可能发生的情况放在最后。**

## 11.3 循环语句

**【规则】重复的代码如果可用循环实现，则必须用循环实现。**

```C++
    // 数组初始化	
    warn[0].word1.all = 0;
	warn[0].word2.all = 0;
	warn[1].word1.all = 0;
	warn[1].word2.all = 0;
	warn[2].word1.all = 0;
	warn[2].word2.all = 0;
	warn[3].word1.all = 0;
	warn[3].word2.all = 0;
	warn[4].word1.all = 0;
	warn[4].word2.all = 0;
	warn[5].word1.all = 0;
	warn[5].word2.all = 0;
	warn[6].word1.all = 0;
	warn[6].word2.all = 0;
	warn[7].word1.all = 0;
	warn[7].word2.all = 0;
	warn[8].word1.all = 0;
	warn[8].word2.all = 0;
	warn[9].word1.all = 0;
	warn[9].word2.all = 0;
	warn[10].word1.all = 0;
	warn[10].word2.all = 0;
	warn[11].word1.all = 0;
	warn[11].word2.all = 0;
	warn[12].word1.all = 0;
	warn[12].word2.all = 0;
	warn[13].word1.all = 0;
	warn[13].word2.all = 0;
	warn[14].word1.all = 0;
	warn[14].word2.all = 0;
	warn[15].word1.all = 0;
	warn[15].word2.all = 0;
    // 改为循环实现
    for (int i=0; i<16; i++)
    {
        warn[i].word1.all = 0;
	    warn[i].word2.all = 0;
    }
```

**【规则】禁止在for循环体内修改循环变量，防止for循环失控。**

**【规则】应保证循环体内工作量最小化。**

```C++
    // 好的代码
    for (int i=0; i<MAX_ADD_NUMBER; i++)
    {
        sum += i;        
    }
    sumBackup = sum;

    // 不好的代码，sumBackup = sum;放在循环中，导致代码执行时间更长
    for (int i=0; i<MAX_ADD_NUMBER; i++)
    {
        sum += i;
        sumBackup = sum;
    }
```

**【建议】在多重循环中，如果有可能，应将次数最多的循环放在最内层，次数最少的循环放在最外层，以减少CPU跨切循环层的次数，提高代码执行效率。**

```C++
// 低效率：长循环在最外层
for (row=0; row<100; row++) 
{ 
    for (col=0; col<5; col++) 
    { 
        sum = sum + a[row][col]; 
    } 
}
// 高效率：长循环在最内层
for (col=0; col<5; col++) 
{ 
    for (row=0; row<100; row++) 
    { 
        sum = sum + a[row][col]; 
    } 
}
```

**【建议】如果循环体内存在逻辑判断，并且循环次数很大，为了提高效率，可考虑将逻辑判断移到循环体的外面。**

下面代码示例1比示例2多执行了 N-1 次逻辑判断，并且由于前者每次循环进行逻辑判断，打断了循环“流水线”作业，使得编译器不能对循环进行优化处理，降低了效率。如果 N 非常大，最好采用示例2的写法，可以提高效率。如果 N 非常小，两者效率差别并不明显，采用示例1的写法比较好，因为程序更加简洁。 

```C++
// 示例1：效率低但程序简洁
for (i=0; i<N; i++) 
{ 
    if (condition)
    {
        DoSomething();
    }     
    else
    {
        DoOtherthing();
    }    
}
// 示例2：效率高但程序不简洁
if (condition) 
{ 
    for (i=0; i<N; i++)
    {
        DoSomething(); 
    }        
} 
else 
{ 
    for (i=0; i<N; i++)
    {
        DoOtherthing();
    }        
}
```



# 12 函数

**【原则】函数功能要单一，一个函数只做一件事。**

**【原则】函数应高内聚，低耦合。**

**【建议】函数规模尽可能小，尽量控制在50行代码之内。**

函数应该可以一屏显示完 (50行以内)，只做一件事情，而且把它做好。过长的函数往往意味着函数功能不单一，过于复杂，或过分呈现细节，未进行进一步抽象。

例外：某些实现算法的函数，由于算法的聚合性与功能的全面性，可能会超过50行。

即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的bug。 建议将其拆分为更加简短并易于管理的若干函数，以便于他人阅读和修改代码。

**【建议】内联函数代码控制在10行以内。**

内联函数具有一般函数的特性，它与一般函数不同之处只在于函数调用的处理。一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中；而内联函数在调用时，是将调用表达式用内联函数体来替换。

内联函数只适合于只有 1~10 行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，也没有必要用内联函数实现，一般的编译器会放弃内联方式，而采用普通的方式调用函数。

如果内联函数包含复杂的控制结构，如循环、分支(switch)、try-catch 等语句，一般编译器将该函数视同普通函数。 **虚函数、递归函数不能被用来做内联函数**。

**【规则】重复代码尽量提炼成函数。**

**【规则】函数应该声明为具有文件作用域。**

**【规则】函数的参数要书写完整，不要只写参数类型不写参数名字，如无参数必须写void。**

```C++
void SetValue(int width, int height); // 良好的风格 
void SetValue(int, int); // 不良的风格 
float GetValue(void); // 良好的风格 
float GetValue(); // 不良的风格 C语言中函数参数为空，表示函数参数个数不确定，而在C++中表示没有参数
```

以下为C语言代码，不写参数的函数示例

```c
#include <stdio.h>

void GiveAnExample();

int main(void)
{
    GiveAnExample();
    GiveAnExample(1);
    GiveAnExample(1, 2);
    GiveAnExample(1.23);
    GiveAnExample("world");

    return 0;
} 

void GiveAnExample()
{
    printf("hello world\n");
}

```

上面代码运行后，输出5行“hello world”。这就说明如果C语言的函数在声明定义的时候没有写参数，实际调用的时候就可以传入任意参数。

**【规则】参数命名要恰当，顺序要合理。**

例如编写字符串拷贝函数 CopyString，它有两个参数。如果把参数名字起为 str1和 str2，例如   

```C++
void CopyString(char *str1, char *str2);
```

 那么我们很难搞清楚究竟是把 str1 拷贝到 str2 中，还是刚好倒过来。可以把参数名字起得更有意义，如叫 strSource 和 strDestination。这样从名字上就可 以看出应该把 strSource 拷贝到 strDestination。

还有一个问题，这两个参数哪个在前哪个在后？参数的顺序要遵循程序员的习惯。一般地，应将目的参数放在前面，源参数放在后面。

 如果将函数声明为： 

```C++
void CopyString(char *strSource, char *strDestination);
```

 别人在使用时可能会不假思索地写成如下形式导致错误： 

```C++
    char str[20];
    CopyString(str, "Hello World"); // 参数顺序颠倒
```

**【规则】如果参数是指针，且仅作输入用，则应在类型前加 const，以防止该指针在函数体内被意外修改。**

```C++
void CopyString(char * const strDestination, const char * const strSource);
```

**【规则】对于引用类型的形参，如果是不需要修改的，请使用const。**

把const作为默认选项，在编译时会对其进行检查，使代码更牢固/更安全。

**【规则】对于不会修改成员变量的成员函数请使用const修饰。**

尽可能将成员函数声明为 const。 访问函数应该总是 const。只要不修改数据成员的成员函数，都声明为const。

```C++
class Foo {
 public:

    // ...

    int PrintValue() const  // const修饰成员函数，不会修改成员变量
    { 
        std::cout << value << std::endl;
    }

    int GetValue() const  // const修饰成员函数，不会修改成员变量
    { 
        return value;
    }

 private:
    int value;
};
```

**【建议】函数参数使用引用取代指针。**

引用比指针更安全，因为它一定非空，且一定不会再指向其他目标；引用不需要检查非法的NULL指针。

选择 const 避免参数被修改，让代码阅读者清晰地知道该参数不被修改，可大大增强代码可读性。

**【规则】如果输入参数以值传递的方式传递对象，则宜改用“const &”方式来传递，这样可以省去临时对象的构造和析构过程，从而提高效率。**

**【建议】避免函数有太多的参数，参数个数尽量控制在 5 个以内。**

如果参数太多，在使用时容易将参数类型或顺序搞错。

如果超过可以考虑：

- 看能否拆分函数
- 看能否将相关参数合在一起，定义结构体

**【规则】函数返回值类型不可省略。**

C语言中，凡不加类型说明的函数，一律自动按整型处理。这样做不会有什么好处，却容易被误解为void类型。

C++语言有很严格的类型安全检查，不允许上述情况发生。由于C++程序可以调用C函数，为了避免混乱，规定任何C/C++函数都必须有返回类型。如果函数没有返回值，那么应声明为void类型。

**【规则】非void类型函数，在每个出口都应有一个含有返回值的return语句，并且返回值与函数返回值类型一致。**

**【规则】不要将正常值和错误标志混在一起返回。正常值用输出参数获得，而错误标志用 return语句返回。**

```C++
/**
* @brief   GetHead()
* @details 读取列表中的第一个条目，不删除
* @param   *y 读取的条目
* @return  操作状态，故障码
*/
INT16 CWarningList::GetHead(TListElem *y)
{
    if (y == nullptr)
    {
        return WL_FAIL;
    }

    if (length <= 0)
    {
        return WL_EMPTY;
    }

    *y = data[(front + 1) % capacity];

    return WL_SUCCESS;
} 
```

**【规则】在函数入口处对参数有效性进行检查。**

**【建议】不仅要检查输入参数的有效性，还要检查函数内用到的其它变量的有效性，比如全局变量，文件等。**

**【建议】尽量避免函数带有“记忆”功能。相同的输入应当产生相同的输出。**

带有“记忆”功能的函数，其行为可能是不可预测的，因为它的行为可能取决于某种“记忆状态”。这样的函数既不易理解又不利于测试和维护。在 C/C++语言中，函数的static 局部变量是函数的“记忆”存储器。**建议尽量少用 static 局部变量，除非必需**。

**【规则】在函数体的出口处，对 return 语句的正确性和效率进行检查。**

注意事项如下

1. **return语句不可返回指向栈内存的指针或引用。**

   因为栈内存在函数结束时自动销毁。
```C++
char * Func(void) 
{ 
    char str[] = “hello world”; // str的内存位于栈上
    return str; // 函数返回时，str指向的内存将被销毁，导致错误 
}
```

2. 要搞清楚返回的究竟是“值”、“指针”还是“引用”。
3. 如果函数返回值是一个对象，要考虑return语句的效率。

```C++
    return String(s1 + s2);
```

这是临时对象的语法，表示“创建一个临时对象并返回它”。不要以为它与“先创建一个局部对象 temp 并返回它的结果”是等价的，如

```C++
    String temp(s1 + s2);
    return temp;  
```

 实质不然，上述代码将发生三件事。首先，temp对象被创建，同时完成初始化；然后拷贝构造函数把temp拷贝到保存返回值的外部存储单元中；最后，temp在函数结束时被销毁（调用析构函数）。然而“创建一个临时对象并返回它”的过程是不同的，编译器直接把临时对象创建并初始化在外部存储单元中，省去了拷贝和析构的化费，提高了效率。

**【建议】不建议使用递归函数。**

有些算法使用分而治之的递归思想，但在嵌入式中栈空间有限，递归本身承载着可用堆栈空间过度的危险，可能导致严重的错误。除非递归经过了非常严格的控制，否则不可能在执行之前确定什么是最坏情况的堆栈使用。

# 13 指针和数组

**【规则】指针必须初始化为NULL。**

**【规则】指针在使用前一定要赋值，避免产生野指针。**

**【规则】取地址操作符`&`不能用于`register`变量。**

**【建议】指针的指针不应超过两级。**

**【规则】指向不同数据类型的指针之间禁止相互转换。**

不同的数据类型长度可能不同，相互转换会导致指针指向的值读写错误。

```C++
// 不规范代码示例
void GiveAnExample(void)
{
    unsigned short var = 3;
    unsigned int *ptr;
    
    ptr = (unsigned int *)&var;  // *ptr可能不等于3
}
```

**【规则】指针转换过程中不应丢失指针的`const`、`volatile`属性。**

```C++
int var;
int *ptr;  // 指向整型的指针
int * const ptr1 = &x; // const指针
const int *ptr2;       // 指向const整型的指针
volatile int *ptr3;    // 指向volatile整型的指针
...
ptr = ptr1;        // 符合规定
ptr = (int *)ptr2; // 不符合规定
ptr = (int *)ptr3; // 不符合规定
```

**【规则】一个未知大小的对象的指针不应成为加法或减法操作的左操作数。**

**【规则】只有指向数组的指针才允许进行算术运算。**

此处的算术运算仅限于指针加减某个整数。

**【规则】只有指向同一数组的两个指针才允许相减。**

**【规则】只有指向同一数组的两个指针才允许用`>`、`>=`、`<`、`<=`等关系运算符进行比较。**

**【规则】对于传递到函数的指针参数，应判断是否为NULL。**

**【规则】调用返回类型为指针的函数后，应判断返回值是否为NULL。**

**【规则】禁止使用未知大小的数组。**

**【规则】当一个数组声明为具有外部链接，它的大小应该显式声明。**

尽管可以在数组声明不完善时访问其元素，然而在数组的大小可以显式确定的情况下，这样做才会更为安全。

```C++
INT16 array[10];      // 符合规范
extern INT16 array[]; // 不符合规范
```

**【规则】数组初始化列表应使用大括号`{}`，并使用附加的大括号来指示嵌套的结构；应显示地考虑和描述复杂数据类型的所有元素，不应忽略某个元素的初始化。**

```C++
// 好的示例
int array[3][2] = {{1, 2}, {3, 4}, {5, 6}};

// 不好的示例
int array[3][2] = {1, 2, 3, 4, 5, 6};
int array[3][2] = {{1, 2}};
```

**【规则】应防止越界操作数组、指针、内存地址等内存空间。**



# 14 内存管理

**【规则】使用malloc等函数申请内存时，必须对分配失败做异常处理。**

**【规则】动态内存的申请和释放必须配对，防止内存泄漏。**

应用场景包括

1. 过程或函数中分配的内存，在过程或函数退出之前要释放；
2. 过程或函数中申请的（为打开文件而使用的）文件句柄，在过程或函数退出之前要关闭。

```C++
// 好的例子
INT16 GiveAnExample(INT16 length)
{
    INT16 *pBuf = NULL;
    pBuf = (INT16*)malloc(BUFFER_LENGTH);
    ......
    free(pBuf);
    return 0
}

// 不好的例子，不是所有分支都释放了申请的内存
INT16 GiveAnExample(INT16 length)
{
    INT16 *pBuf = NULL;
    pBuf = (INT16*)malloc(BUFFER_LENGTH);
    ......
    if (length > BUFFER_LENGTH)
    {
        free(pBuf);
        return 1;
    }
    return 0
}
```

**【规则】单个对象释放使用delete，数组对象释放使用delete []。**

说明：单个对象删除使用delete， 数组对象删除使用delete []，原因：

- 调用new所包含的动作：从系统中申请一块内存，并调用此类型的构造函数。
- 调用new[n]所包含的动作：申请可容纳n个对象的内存，并且对每一个对象调用其构造函数。
- 调用delete所包含的动作：先调用相应的析构函数，再将内存归还系统。
- 调用delete[]所包含的动作：对每一个对象调用析构函数，再释放所有内存

如果new和delete的格式不匹配，结果是未知的。对于非class类型， new和delete不会调用构造与析构函数。

**【规则】禁止使用已释放的内存空间。**

**【规则】应防止越界操作数组、指针、内存地址等内存空间。**

**【规则】字符串连接宜使用strncat库函数代替strcat库函数，字符串拷贝已使用strncpy库函数代替strcpy库函数，避免长度不够引起的数组越界。**

**【规则】使用sprintf库函数时，应注意字符长度，避免长度不够引起的数组越界。**

**【建议】对于内存受限的系统，宜减少使用动态内存分配，多采用静态内存分配，在程序编译时就确定所需的空间。**

**【规则】对于动态分配的内存指针和文件句柄，在定义的时候应初始化为空，访问的时候应判断是否为空，在释放完成后设置为空。**



# 15 中断程序

**【规则】中断服务程序不应带回返回值。**

**【规则】不应在中断程序中使用printf、malloc等函数。**

**【规则】多个中断（或多线程）对同一数据进行读写操作，必须做互斥或同步处理。**

**【规则】对于中断的开关，应注意成对匹配。**

对于默认开启的中断，如果在某个函数中关闭，在函数退出时需相应开启；对于默认关闭的中断，如果在某个函数中开启，在函数退出时需相应关闭。

**【规则】不建议使用位域变量。**



# 16 硬件相关

**【规则】系统运行之初，应初始化有关变量及运行环境。**

**【建议】系统运行之初，应对加载到系统中的数据进行一致性检查。**

**【规则】硬件初始化程序，要注意时序要求。**

**【规则】编程中关注芯片的存储空间——如程序空间、数据空间、堆栈空间等大小是否超出范围。**

**【规则】在程序中宜使用芯片提供的看门狗功能实现硬件系统复位。**

**【规则】注意CPU对各种存储器的访问速度，在程序中宜利用各种硬件设备自身的特点来提高程序效率。**

```C++
// 把复杂的计算放到ram中执行，提高效率
#pragma CODE_SECTION(".RamFuncs")
void ParkTransformation(FLOAT32 wt, const ABC * const abc, DQ *dq0)
{
    ；
}
```



# TODO

内存管理补充

作用域-命名空间

类补充

模板

标准库



# 参考文献

>  1、 高质量C++/C编程指南 林锐
>
>  2、Google C++ 编程规范
>
>  3、华为技术有限公司C++语言编程规范
>
>  4、华为技术有限公司C语言编程规范
>
>  5、GB/T 28169-2011 嵌入式软件 C语言编码规范
>
>  6、方舟编译器编程规范 https://www.openarkcompiler.cn/document/rules